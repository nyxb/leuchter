// based on https://github.dev/shikijs/shiki/blob/99a9a3dcd2f2504d36b0672968fb05be53fd73cb/scripts/grammars/updateGrammarSourceFiles.ts
// License MIT Pine Wu
import fs from 'node:fs'
import { parse as jsoncParse } from 'jsonc-parser'
import consolji from 'consolji'

consolji.log('Updating leuchter/scripts/languages.mjs...')

const languageAliases = {
   'bat': ['batch'],
   'berry': ['be'],
   'cadence': ['cdc'],
   'clojure': ['clj'],
   'codeql': ['ql'],
   'csharp': ['c#', 'cs'],
   'docker': ['dockerfile'],
   'erlang': ['erl'],
   'fsharp': ['f#', 'fs'],
   'haskell': ['hs'],
   'handlebars': ['hbs'],
   'ini': ['properties'],
   'javascript': ['js'],
   'jssm': ['fsl'],
   'kusto': ['kql'],
   'make': ['makefile'],
   'markdown': ['md'],
   'objective-c': ['objc'],
   'powershell': ['ps', 'ps1'],
   'pug': ['jade'],
   'python': ['py'],
   'raku': ['perl6'],
   'ruby': ['rb'],
   'rust': ['rs'],
   'html-ruby-erb': ['erb'],
   'shaderlab': ['shader'],
   'shellscript': ['bash', 'console', 'sh', 'shell', 'zsh'],
   'stylus': ['styl'],
   'typescript': ['ts'],
   'vb': ['cmd'],
   'viml': ['vim', 'vimscript'],
   'wenyan': ['文言'],
   'yaml': ['yml'],
}

const idsToIgnore = ['jinja', 'php-html', 'cpp-macro']

function getLanguagesData() {
   const files = fs.readdirSync('./grammars')
   const ids = files
      .map(f => f.replace('.tmLanguage.json', ''))
      .filter(id => !idsToIgnore.includes(id))

   const scopeToIdMap = {}
   const idToGrammar = {}
   ids.forEach((id) => {
      const src = fs.readFileSync(`grammars/${id}.tmLanguage.json`, 'utf-8')
      const errors = []
      const json = jsoncParse(src, errors, { allowTrailingComma: true })
      if (errors.length)
         throw errors[0]

      idToGrammar[id] = { src, json }
      scopeToIdMap[json.scopeName] = id
   })

   return ids.map((id) => {
      const grammarSrc = idToGrammar[id].src
      const grammar = idToGrammar[id].json

      const data = {
         id,
         scopeName: grammar.scopeName,
         path: `${id}.tmLanguage.json`,
      }

      if (languageAliases[id])
         data.aliases = languageAliases[id]

      const embeddedLangs = new Set()
      const matches = [...grammarSrc.matchAll(/"include": "([^#$].+)"/g)]
      matches.forEach(([, captured]) => {
         const scope = captured.split('#')[0]
         if (
            !grammar.scopeName
        || (grammar.scopeName && scope !== grammar.scopeName)
         ) {
            if (scopeToIdMap[scope])
               embeddedLangs.add(scopeToIdMap[scope])
         }
      })

      if (embeddedLangs.size > 0)
         data.embeddedLangs = [...embeddedLangs]

      return data
   })
}

const result = getLanguagesData()
const content = `// generated by leuchter/scripts/2.update-languages.mjs
export const languages = ${JSON.stringify(result, null, 2)};`

fs.writeFileSync('./scripts/languages.mjs', content, 'utf8')

consolji.log('Done updating leuchter/scripts/languages.mjs')
